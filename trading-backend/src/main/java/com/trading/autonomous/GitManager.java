package com.trading.autonomous;

import org.eclipse.jgit.api.*;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.PersonIdent;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.time.Instant;

/**
 * Git integration for automated version control of code fixes.
 * Automatically commits and pushes code changes with detailed messages.
 */
public class GitManager {
    private static final Logger logger = LoggerFactory.getLogger(GitManager.class);
    
    private final Git git;
    private final boolean pushEnabled;
    
    public GitManager(String repoPath, boolean pushEnabled) throws IOException, GitAPIException {
        this.pushEnabled = pushEnabled;
        
        // Open or initialize Git repository
        File gitDir = new File(repoPath, ".git");
        if (!gitDir.exists()) {
            logger.info("üîß Initializing new Git repository at: {}", repoPath);
            this.git = Git.init().setDirectory(new File(repoPath)).call();
        } else {
            Repository repository = new FileRepositoryBuilder()
                .setGitDir(gitDir)
                .build();
            this.git = new Git(repository);
        }
        
        logger.info("üì¶ GitManager initialized (push: {})", pushEnabled);
    }
    
    /**
     * Commit code fix with detailed message.
     */
    public CommitResult commitFix(ClaudeCodeGenerator.CodeFix fix, 
                                  ErrorDetector.ErrorPattern pattern,
                                  int errorCount) {
        try {
            // 1. Create auto-heal branch
            String branchName = "auto-heal/" + pattern.name().toLowerCase().replace("_", "-");
            createBranch(branchName);
            
            // 2. Stage changes
            git.add()
                .addFilepattern("src/")
                .addFilepattern("pom.xml")
                .call();
            
            // 3. Commit with detailed message
            String commitMessage = generateCommitMessage(fix, pattern, errorCount);
            var commit = git.commit()
                .setMessage(commitMessage)
                .setAuthor(new PersonIdent("AutoHeal Bot", "bot@trading.com"))
                .call();
            
            String commitHash = commit.getName().substring(0, 7);
            logger.info("‚úÖ Committed fix: {} ({})", commitHash, pattern.name());
            
            // 4. Tag commit
            String tagName = "auto-heal-" + System.currentTimeMillis();
            git.tag()
                .setName(tagName)
                .setMessage("Auto-heal: " + pattern.name())
                .call();
            
            logger.info("üè∑Ô∏è  Tagged commit: {}", tagName);
            
            // 5. Push to remote (if enabled)
            if (pushEnabled) {
                pushToRemote(branchName);
            }
            
            return new CommitResult(true, commitHash, branchName, tagName, null);
            
        } catch (Exception e) {
            logger.error("‚ùå Failed to commit fix", e);
            return new CommitResult(false, null, null, null, e.getMessage());
        }
    }
    
    /**
     * Create or checkout branch.
     */
    private void createBranch(String branchName) throws GitAPIException {
        try {
            git.checkout()
                .setCreateBranch(true)
                .setName(branchName)
                .call();
            logger.info("üåø Created branch: {}", branchName);
        } catch (Exception e) {
            // Branch might already exist, try to checkout
            git.checkout()
                .setName(branchName)
                .call();
            logger.info("üåø Checked out existing branch: {}", branchName);
        }
    }
    
    /**
     * Generate detailed commit message.
     */
    private String generateCommitMessage(ClaudeCodeGenerator.CodeFix fix,
                                        ErrorDetector.ErrorPattern pattern,
                                        int errorCount) {
        return String.format("""
            [AUTO-HEAL] Fix %s
            
            Error Pattern: %s
            Occurrences: %d times
            Severity: HIGH
            
            Fix Description:
            %s
            
            Changes:
            - File: %s
            - Lines modified: %d
            
            Validation:
            %s
            
            Generated by: Claude 3.5 Sonnet
            Tested: Yes (sandbox passed)
            Auto-committed: %s
            """,
            pattern.name(),
            pattern.regex(),
            errorCount,
            fix.explanation(),
            fix.filePath(),
            fix.codeLines().size(),
            fix.validation(),
            Instant.now()
        );
    }
    
    /**
     * Push to remote repository.
     */
    private void pushToRemote(String branchName) {
        try {
            git.push()
                .setRemote("origin")
                .add(branchName)
                .call();
            logger.info("üì§ Pushed to remote: {}", branchName);
        } catch (Exception e) {
            logger.warn("‚ö†Ô∏è  Failed to push to remote (continuing anyway): {}", e.getMessage());
        }
    }
    
    /**
     * Rollback last commit (if needed).
     */
    public void rollback() {
        try {
            git.reset()
                .setMode(ResetCommand.ResetType.HARD)
                .setRef("HEAD~1")
                .call();
            logger.info("üîÑ Rolled back last commit");
        } catch (Exception e) {
            logger.error("‚ùå Failed to rollback", e);
        }
    }
    
    public void close() {
        git.close();
    }
    
    /**
     * Commit result.
     */
    public record CommitResult(
        boolean success,
        String commitHash,
        String branchName,
        String tagName,
        String errorMessage
    ) {}
}
